/*
 * ubx_kinova_gen3 microblx function block (autogenerated, don't edit)
 */

#include <ubx.h>

UBX_MODULE_LICENSE_SPDX(LGPL3)

/* includes types and type metadata */

ubx_type_t types[] = {
};

/* block meta information */
char ubx_kinova_gen3_meta[] =
	" { doc='',"
	"   realtime=true,"
	"}";

/* declaration of block configuration */
ubx_proto_config_t ubx_kinova_gen3_config[] = {
	{ .name="ctrl_mode", .type_name = "int", .min=0, .max=1, .doc="initial ctrl_mode: 0: pos (def), 1: vel, 2: eff, 3: cur" },
	{ .name="ip_address", .type_name = "char", .min=0, .max=0, .doc="" },
	{ .name="port", .type_name = "int", .min=0, .max=0, .doc="" },
	{ .name="port_real_time", .type_name = "int", .min=0, .max=0, .doc="" },
	{ .name="user", .type_name = "char", .min=0, .max=0, .doc="" },
	{ .name="password", .type_name = "char", .min=0, .max=0, .doc="" },
	{ .name="session_timeout", .type_name = "int", .min=0, .max=0, .doc="[ms]" },
	{ .name="connection_timeout", .type_name = "int", .min=0, .max=0, .doc="[ms]" },
	{ 0 },
};

/* declaration port block ports */
ubx_proto_port_t ubx_kinova_gen3_ports[] = {
	{ .name="ctrl_mode", .in_type_name="int", .in_data_len=1, .doc="port to switch control modes at runtime"  },
	{ .name="pos_msr", .out_type_name="double", .out_data_len=7, .doc="Measured joint position [rad]"  },
	{ .name="pos_cmd", .in_type_name="double", .in_data_len=7, .doc="Commanded joint position [rad]"  },
	{ .name="vel_msr", .out_type_name="double", .out_data_len=7, .doc="Measured joint velocity [rad/s]"  },
	{ .name="vel_cmd", .in_type_name="double", .in_data_len=7, .doc="Commanded joint velocity [rad/s]"  },
	{ .name="eff_msr", .out_type_name="double", .out_data_len=7, .doc="Measured joint effort [Nm]"  },
	{ .name="eff_cmd", .in_type_name="double", .in_data_len=7, .doc="Commanded joint effort [Nm]"  },
	{ .name="cur_msr", .out_type_name="double", .out_data_len=7, .doc="Measured joint current [A]"  },
	{ .name="cur_cmd", .in_type_name="double", .in_data_len=7, .doc="Commanded joint current [A]"  },
	{ 0 },
};

/* declare a struct port_cache */
struct ubx_kinova_gen3_port_cache {
	ubx_port_t* ctrl_mode;
	ubx_port_t* pos_msr;
	ubx_port_t* pos_cmd;
	ubx_port_t* vel_msr;
	ubx_port_t* vel_cmd;
	ubx_port_t* eff_msr;
	ubx_port_t* eff_cmd;
	ubx_port_t* cur_msr;
	ubx_port_t* cur_cmd;
};

/* helper function to cache ports. call in init */
static void update_port_cache(ubx_block_t *b, struct ubx_kinova_gen3_port_cache *pc)
{
	pc->ctrl_mode = ubx_port_get(b, "ctrl_mode");
	pc->pos_msr = ubx_port_get(b, "pos_msr");
	pc->pos_cmd = ubx_port_get(b, "pos_cmd");
	pc->vel_msr = ubx_port_get(b, "vel_msr");
	pc->vel_cmd = ubx_port_get(b, "vel_cmd");
	pc->eff_msr = ubx_port_get(b, "eff_msr");
	pc->eff_cmd = ubx_port_get(b, "eff_cmd");
	pc->cur_msr = ubx_port_get(b, "cur_msr");
	pc->cur_cmd = ubx_port_get(b, "cur_cmd");
}

/* define safe accessors for the new types */


/* block operation forward declarations */
int ubx_kinova_gen3_init(ubx_block_t *b);
int ubx_kinova_gen3_start(ubx_block_t *b);
void ubx_kinova_gen3_stop(ubx_block_t *b);
void ubx_kinova_gen3_cleanup(ubx_block_t *b);
void ubx_kinova_gen3_step(ubx_block_t *b);

ubx_proto_block_t ubx_kinova_gen3_block = {
	.name = "ubx_kinova_gen3",
	.type = BLOCK_TYPE_COMPUTATION,
	.meta_data = ubx_kinova_gen3_meta,
	.configs = ubx_kinova_gen3_config,
	.ports = ubx_kinova_gen3_ports,

	/* ops */
	.init = ubx_kinova_gen3_init,
	.start = ubx_kinova_gen3_start,
	.stop = ubx_kinova_gen3_stop,
	.cleanup = ubx_kinova_gen3_cleanup,
	.step = ubx_kinova_gen3_step,
};


/* ubx_kinova_gen3 module init and cleanup functions */
int ubx_kinova_gen3_mod_init(ubx_node_t* nd)
{
	ubx_log(UBX_LOGLEVEL_DEBUG, nd, "%s", __func__);

	for (unsigned int i=0; i<ARRAY_SIZE(types); i++) {
		if(ubx_type_register(nd, &types[i]) != 0)
			return -1;
	}

	if(ubx_block_register(nd, &ubx_kinova_gen3_block) != 0)
		return -1;

	return 0;
}

void ubx_kinova_gen3_mod_cleanup(ubx_node_t *nd)
{
	ubx_log(UBX_LOGLEVEL_DEBUG, nd, "%s", __func__);

	for (unsigned int i=0; i<ARRAY_SIZE(types); i++)
		ubx_type_unregister(nd, types[i].name);

	ubx_block_unregister(nd, "ubx_kinova_gen3");
}

/* declare module init and cleanup functions, so that the ubx core can
 * find these when the module is loaded/unloaded */
UBX_MODULE_INIT(ubx_kinova_gen3_mod_init)
UBX_MODULE_CLEANUP(ubx_kinova_gen3_mod_cleanup)
